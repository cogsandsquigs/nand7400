// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!


// Unit struct to parameterize the FfiConverter trait.
//
// We use FfiConverter<UniFfiTag> to handle lowering/lifting/serializing types for this crate.  See
// https://mozilla.github.io/uniffi-rs/internals/lifting_and_lowering.html#code-generation-and-the-fficonverter-trait
// for details.
//
// This is pub, since we need to access it to support external types
#[doc(hidden)]
pub struct UniFfiTag;

#[allow(clippy::missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn ffi_Nand7400_uniffi_contract_version() -> u32 {
    22
}
/// Export namespace metadata.
///
/// See `uniffi_bindgen::macro_metadata` for how this is used.

const UNIFFI_META_CONST_NAMESPACE_NAND7400: ::uniffi::MetadataBuffer = ::uniffi::MetadataBuffer::from_code(::uniffi::metadata::codes::NAMESPACE)
    .concat_str(env!("CARGO_CRATE_NAME"))
    .concat_str("Nand7400");

#[doc(hidden)]
#[no_mangle]
pub static UNIFFI_META_NAMESPACE_NAND7400: [u8; UNIFFI_META_CONST_NAMESPACE_NAND7400.size] = UNIFFI_META_CONST_NAMESPACE_NAND7400.into_array();

// Check for compatibility between `uniffi` and `uniffi_bindgen` versions.
// Note that we have an error message on the same line as the assertion.
// This is important, because if the assertion fails, the compiler only
// seems to show that single line as context for the user.
uniffi::assert_compatible_version!("0.24.3"); // Please check that you depend on version 0.24.3 of the `uniffi` crate.



















// Everybody gets basic buffer support, since it's needed for passing complex types over the FFI.
//
// See `uniffi/src/ffi/rustbuffer.rs` for documentation on these functions

#[allow(clippy::missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn ffi_Nand7400_rustbuffer_alloc(size: i32, call_status: &mut uniffi::RustCallStatus) -> uniffi::RustBuffer {
    uniffi::ffi::uniffi_rustbuffer_alloc(size, call_status)
}

#[allow(clippy::missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_Nand7400_rustbuffer_from_bytes(bytes: uniffi::ForeignBytes, call_status: &mut uniffi::RustCallStatus) -> uniffi::RustBuffer {
    uniffi::ffi::uniffi_rustbuffer_from_bytes(bytes, call_status)
}

#[allow(clippy::missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_Nand7400_rustbuffer_free(buf: uniffi::RustBuffer, call_status: &mut uniffi::RustCallStatus) {
    uniffi::ffi::uniffi_rustbuffer_free(buf, call_status);
}

#[allow(clippy::missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_Nand7400_rustbuffer_reserve(buf: uniffi::RustBuffer, additional: i32, call_status: &mut uniffi::RustCallStatus) -> uniffi::RustBuffer {
    uniffi::ffi::uniffi_rustbuffer_reserve(buf, additional, call_status)
}



// Error definitions, corresponding to `error` in the UDL.


#[::uniffi::ffi_converter_error(
    tag = crate::UniFfiTag,
    
)]
enum r#AssemblerError {
    r#Parsing {
        r#source: r#ParsingError,
    },
    r#WrongNumArgs {
        r#mnemonic: String,
        r#expected: u16,
        r#given: u16,
        r#mnemonic_span: r#Position,
        r#args_span: r#Position,
    },
    r#WrongArgType {
        r#mnemonic: String,
        r#expected: r#OpcodeArg,
        r#given: r#OpcodeArg,
        r#mnemonic_span: r#Position,
        r#arg_span: r#Position,
    },
    r#OpcodeDNE {
        r#mnemonic: String,
        r#span: r#Position,
    },
    r#LabelDNE {
        r#mnemonic: String,
        r#span: r#Position,
    },
}



// Enum definitions, corresponding to `enum` in UDL.


#[::uniffi::ffi_converter_enum(tag = crate::UniFfiTag)]
enum r#OpcodeArg {
    r#Indirect {
    },
    r#Immediate {
    },
}



// Error definitions, corresponding to `error` in the UDL.


#[::uniffi::ffi_converter_error(
    tag = crate::UniFfiTag,
    
)]
enum r#ParsingError {
    r#UnknownCharacter {
        r#character: String,
        r#span: r#Position,
    },
    r#Unexpected {
        r#expected: std::vec::Vec<r#TokenKind>,
        r#found: r#TokenKind,
        r#span: r#Position,
    },
    r#Overflow {
        r#literal: String,
        r#span: r#Position,
    },
    r#Underflow {
        r#literal: String,
        r#span: r#Position,
    },
    r#EmptyLiteral {
        r#span: r#Position,
    },
    r#KeywordDNE {
        r#mnemonic: String,
        r#span: r#Position,
    },
}



// Enum definitions, corresponding to `enum` in UDL.


#[::uniffi::ffi_converter_enum(tag = crate::UniFfiTag)]
enum r#TokenKind {
    r#Eof {
    },
    r#Invalid {
    },
    r#Newline {
    },
    r#Ident {
    },
    r#Colon {
    },
    r#Semicolon {
    },
    r#Plus {
    },
    r#Minus {
    },
    r#Hash {
    },
    r#Number {
    },
    r#Keyword {
    },
}



// Record definitions, implemented as method-less structs, corresponding to `dictionary` objects.



#[::uniffi::ffi_converter_record(tag = crate::UniFfiTag)]
struct r#AssemblerConfig {
    r#opcodes: std::vec::Vec<r#Opcode>,
}



#[::uniffi::ffi_converter_record(tag = crate::UniFfiTag)]
struct r#Opcode {
    r#mnemonic: String,
    r#binary: u8,
    r#args: std::vec::Vec<r#OpcodeArg>,
}



#[::uniffi::ffi_converter_record(tag = crate::UniFfiTag)]
struct r#Position {
    r#start: u32,
    r#end: u32,
}


// Top level functions, corresponding to UDL `namespace` functions.// Object definitions, corresponding to UDL `interface` definitions.

// For each Object definition, we assume the caller has provided an appropriately-shaped `struct T`
// with an `impl` for each method on the object. We create an `Arc<T>` for "safely" handing out
// references to these structs to foreign language code, and we provide a `pub extern "C"` function
// corresponding to each method.
//
// (Note that "safely" is in "scare quotes" - that's because we use functions on an `Arc` that
// that are inherently unsafe, but the code we generate is safe in practice.)
//
// If the caller's implementation of the struct does not match with the methods or types specified
// in the UDL, then the rust compiler will complain with a (hopefully at least somewhat helpful!)
// error message when processing this generated code.
#[::uniffi::ffi_converter_interface(tag = crate::UniFfiTag)]
struct r#Assembler { }


// All Object structs must be `Sync + Send`. The generated scaffolding will fail to compile
// if they are not, but unfortunately it fails with an unactionably obscure error message.
// By asserting the requirement explicitly, we help Rust produce a more scrutable error message
// and thus help the user debug why the requirement isn't being met.
uniffi::deps::static_assertions::assert_impl_all!(r#Assembler: Sync, Send);

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn uniffi_Nand7400_fn_free_assembler(ptr: *const std::os::raw::c_void, call_status: &mut uniffi::RustCallStatus) {
    uniffi::rust_call(call_status, || {
        assert!(!ptr.is_null());
        drop(unsafe { ::std::sync::Arc::from_raw(ptr as *const r#Assembler) });
        
        Ok(())
    })
}
    #[doc(hidden)]
    #[no_mangle]
    pub extern "C" fn r#uniffi_Nand7400_fn_constructor_assembler_new(
        r#config: ::uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus
    ) -> *const std::os::raw::c_void /* *const Assembler */ {
        uniffi::deps::log::debug!("uniffi_Nand7400_fn_constructor_assembler_new");

        // If the constructor does not have the same signature as declared in the UDL, then
        // this attempt to call it will fail with a (somewhat) helpful compiler error.
        uniffi::rust_call(call_status, || {
            <std::sync::Arc<r#Assembler> as ::uniffi::FfiConverter<crate::UniFfiTag>>::lower_return(
                ::std::sync::Arc::new(r#Assembler::r#new(
        match<r#AssemblerConfig as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#config) {
        
            Ok(val) => val,
            Err(err) => panic!("Failed to convert arg '{}': {}", "config", err),
        }))
            )
        })
    }
    
#[doc(hidden)]
#[no_mangle]
#[allow(clippy::let_unit_value,clippy::unit_arg)] // The generated code uses the unit type like other types to keep things uniform
pub extern "C" fn r#uniffi_Nand7400_fn_method_assembler_set_config(
        r#ptr: *const std::os::raw::c_void,
        r#config: ::uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus
)  {
    uniffi::deps::log::debug!("uniffi_Nand7400_fn_method_assembler_set_config");
    uniffi::rust_call(call_status, || {
        <() as ::uniffi::FfiConverter<crate::UniFfiTag>>::lower_return(
            <r#Assembler>::r#set_config(
        match<std::sync::Arc<r#Assembler> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#ptr) {
        
            Ok(ref val) => val,
            Err(err) => panic!("Failed to convert arg '{}': {}", "ptr", err),
        },
        match<r#AssemblerConfig as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#config) {
        
            Ok(val) => val,
            Err(err) => panic!("Failed to convert arg '{}': {}", "config", err),
        })
    
            
        )
    })
}


    
#[doc(hidden)]
#[no_mangle]
#[allow(clippy::let_unit_value,clippy::unit_arg)] // The generated code uses the unit type like other types to keep things uniform
pub extern "C" fn r#uniffi_Nand7400_fn_method_assembler_assemble(
        r#ptr: *const std::os::raw::c_void,
        r#source: ::uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus
)  -> <Vec<u8> as ::uniffi::FfiConverter<crate::UniFfiTag>>::ReturnType {
    uniffi::deps::log::debug!("uniffi_Nand7400_fn_method_assembler_assemble");
    uniffi::rust_call(call_status, || {
        <::std::result::Result<Vec<u8>, r#AssemblerError> as ::uniffi::FfiConverter<crate::UniFfiTag>>::lower_return(
            <r#Assembler>::r#assemble(
        match<std::sync::Arc<r#Assembler> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#ptr) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#AssemblerError>(err, "ptr")),
        },
        match<String as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#source) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#AssemblerError>(err, "source")),
        })
    
            .map_err(Into::into)
        )
    })
}




// Callback Interface definitions, corresponding to UDL `callback interface` definitions.


// External and Wrapped types
// Support for external types.

// Types with an external `FfiConverter`...


// For custom scaffolding types we need to generate an FfiConverter impl based on the
// UniffiCustomTypeConverter implementation that the library supplies


// Export scaffolding checksums

#[no_mangle]
#[doc(hidden)]
pub extern "C" fn r#uniffi_Nand7400_checksum_method_assembler_set_config() -> u16 {
    8975
}
#[no_mangle]
#[doc(hidden)]
pub extern "C" fn r#uniffi_Nand7400_checksum_method_assembler_assemble() -> u16 {
    16022
}
#[no_mangle]
#[doc(hidden)]
pub extern "C" fn r#uniffi_Nand7400_checksum_constructor_assembler_new() -> u16 {
    22757
}

// The `reexport_uniffi_scaffolding` macro
// Code to re-export the UniFFI scaffolding functions.
//
// Rust won't always re-export the functions from dependencies
// ([rust-lang#50007](https://github.com/rust-lang/rust/issues/50007))
//
// A workaround for this is to have the dependent crate reference a function from its dependency in
// an extern "C" function. This is clearly hacky and brittle, but at least we have some unittests
// that check if this works (fixtures/reexport-scaffolding-macro).
//
// The main way we use this macro is for that contain multiple UniFFI components (libxul,
// megazord).  The combined library has a cargo dependency for each component and calls
// uniffi_reexport_scaffolding!() for each one.

#[allow(missing_docs)]
#[doc(hidden)]
pub const fn uniffi_reexport_hack() {}

#[doc(hidden)]
#[macro_export]
macro_rules! uniffi_reexport_scaffolding {
    () => {
        #[doc(hidden)]
        #[no_mangle]
        pub extern "C" fn Nand7400_uniffi_reexport_hack() {
            $crate::uniffi_reexport_hack()
        }
    };
}